---
alwaysApply: true
description: Present options for large dependencies before installing
---

# Dependency Management

## Core Principle

Before adding **large dependencies** (>500kb), present alternatives so the user can make an informed choice.

## The Rule

### ğŸ“¦ Dependency Size Thresholds

- **< 100kb**: Add directly, mention in commit âœ…
- **100-500kb**: Add, briefly note the size âš ï¸
- **> 500kb**: PAUSE and present alternatives ğŸ›‘

### ğŸ›‘ When Adding Large Dependency (>500kb)

Stop and present analysis:

```
ğŸ“¦ Analisando dependÃªncia solicitada:

VocÃª pediu: [feature/functionality]
Sugeri: [library name]

ğŸ“Š AnÃ¡lise da Lib:

Biblioteca: moment.js
Tamanho: 2.3 MB (minified) âš ï¸
ManutenÃ§Ã£o: Ativa
Download semanal: 15M

âœ… PrÃ³s:
- API completa para datas
- Muito bem documentada
- Amplamente usada

âš ï¸ Contras:
- Tamanho grande (2.3MB)
- MutÃ¡vel (pode causar bugs)
- Em "maintenance mode"

---

ğŸ“¦ Alternativas:

OpÃ§Ã£o A: date-fns
Tamanho: 78 KB (tree-shakeable)
PrÃ³s: Modular, imutÃ¡vel, moderno
Contras: Sintaxe diferente de moment

OpÃ§Ã£o B: day.js  
Tamanho: 7 KB
PrÃ³s: API compatÃ­vel com moment, tiny
Contras: Menos features completas

OpÃ§Ã£o C: Nativa (Intl.DateTimeFormat)
Tamanho: 0 KB (built-in)
PrÃ³s: Zero dependencies
Contras: API mais verbosa

---

â“ Qual opÃ§Ã£o prefere? (moment / date-fns / day.js / nativa)
```

## When to Present Alternatives

### âœ… Present alternatives for:

- Date/time libraries (>500kb)
- Lodash (suggest native alternatives)
- Large UI libraries (suggest smaller alternatives)
- Formatting libraries (suggest built-in Intl)
- Validation libraries (suggest smaller options)

### âŒ Don't present for:

- Framework core (React, Next.js) - essential
- Tools explicitly in escopo.md pre-approved list
- Dependencies <100kb
- Dev dependencies (not in production bundle)

## Analysis Template

```
ğŸ“¦ [Library Name]
Tamanho: [size] (minified/gzipped)
Ãšltima atualizaÃ§Ã£o: [date]
ManutenÃ§Ã£o: [Active/Maintenance/Deprecated]

âœ… PrÃ³s:
- [benefit 1]
- [benefit 2]

âš ï¸ Contras:
- [drawback 1]
- [drawback 2]

ğŸ“¦ Melhor para: [use case]
```

## Native Dependencies Warning

### Core Principle

Before adding ANY dependency that compiles native code, warn user about build requirements and present pure JS alternatives.

### How to Identify Native Dependencies

**Common native dependencies:**
- better-sqlite3 (SQLite)
- bcrypt (password hashing)
- sharp (image processing)
- canvas (canvas manipulation)
- sqlite3 (SQLite)
- argon2 (password hashing)
- node-sass (Sass compiler)
- node-gyp (build system)

**Detection signs:**
- Has "node-gyp" in dependencies
- Requires Python/C++ compiler
- Has "binding.gyp" file in package
- Listed in [node-gyp dependencies](https://github.com/nodejs/node-gyp/wiki/Node-gyp's-Wiki)

### When Detected

Stop and present analysis:
âš ï¸ DependÃªncia Nativa Detectada
VocÃª pediu: [feature]
Sugeri: [native library]
ğŸ“Š AnÃ¡lise:
Biblioteca: [name]
Tipo: CompilaÃ§Ã£o nativa (C++/Rust/etc)
Tamanho: [size]
âœ… PrÃ³s:

Performance superior
[other benefits]

âš ï¸ Contras:

Windows: Requer Visual Studio Build Tools (~6GB)
macOS: Requer Xcode Command Line Tools
Linux: Requer build-essential
CompilaÃ§Ã£o mais lenta no npm install
Pode falhar em ambientes restritos (CI/CD, Docker)


ğŸ“¦ Alternativa Pura JS:
Biblioteca: [alternative]
Tipo: JavaScript puro (sem compilaÃ§Ã£o)
Tamanho: [size]
Performance: [comparison - ex: "95% da nativa" ou "suficiente para apps pequenos"]
âœ… PrÃ³s:

Zero requisitos de build
Funciona em qualquer ambiente
npm install instantÃ¢neo
Portabilidade total

âš ï¸ Contras:

[performance trade-off if significant]


â“ Qual opÃ§Ã£o prefere?
A) [native library] (melhor performance, requer build tools)
B) [pure JS alternative] (sem requisitos, boa performance)
Para projetos pequenos/mÃ©dios: recomendo B
Para projetos grandes com alta carga: considere A

### Alternative Recommendations

**Database:**
- better-sqlite3 â†’ @libsql/client OR sql.js
- sqlite3 â†’ @libsql/client OR sql.js

**Crypto/Hashing:**
- bcrypt â†’ bcryptjs
- argon2 â†’ @noble/hashes (argon2)

**Images:**
- sharp â†’ jimp OR canvas (pure JS) OR @squoosh/lib

**Canvas:**
- canvas â†’ rough-canvas (pure JS, limited features)

### Exception: When NOT to Present

**Don't warn if:**
- Dependency is in escopo.md pre-approved list
- User explicitly asked for the native version
- Project is large-scale (escopo says "Large" complexity)
- No pure JS alternative exists

### Integration Points

- Applies during PLAN phase (workflow rule)
- Before installing dependency >500kb (size rule)
- When generating package.json (MP-02)

---

## Common Scenarios

### Scenario 1: Date Handling

Instead of auto-adding moment.js (2.3MB):
â†’ Present: date-fns (78KB) vs day.js (7KB) vs native

### Scenario 2: Utility Functions

Instead of auto-adding full lodash (70KB):
â†’ Present: lodash-es (tree-shakeable) vs native methods

### Scenario 3: Form Validation

Instead of auto-adding yup (40KB) + ajv (120KB):
â†’ Present: zod (50KB total) vs joi vs native validation

### Scenario 4: HTTP Client

Instead of auto-adding axios (13KB):
â†’ Present: native fetch (0KB) vs ky (8KB) vs axios
â†’ Note: For simple cases, fetch is enough

### Scenario 5: State Management

Instead of auto-adding Redux Toolkit (45KB):
â†’ Present: Zustand (3KB) vs Jotai (5KB) vs Context API (0KB)

## Integration with Other Rules

- **10-tool-selection.mdc**: This handles dependencies, that handles tools/services
- **00-universal-workflow.mdc**: Present alternatives in PLAN phase
- **00-universal-ask-first.mdc**: This asks about WHICH lib, that asks about HOW to use

## Examples

### Example 1: Large Lib Detected âœ…

```
User: "Add rich text editor"

AI: "Para rich text editor, considerando:

ğŸ“¦ OpÃ§Ã£o A: TinyMCE
Tamanho: 500 KB âš ï¸
âœ… PrÃ³s: Features completas, WYSIWYG robusto
âš ï¸ Contras: Tamanho, precisa CDN ou config complexa

ğŸ“¦ OpÃ§Ã£o B: Slate.js
Tamanho: 180 KB
âœ… PrÃ³s: Moderno, extensÃ­vel, React-first
âš ï¸ Contras: API mais complexa

ğŸ“¦ OpÃ§Ã£o C: Lexical (Meta)
Tamanho: 90 KB
âœ… PrÃ³s: PerformÃ¡tico, moderno
âš ï¸ Contras: Docs ainda em evoluÃ§Ã£o

â“ Qual editor prefere? (A/B/C)"
```

### Example 2: Small Lib, No Need to Ask âœ…

```
User: "Add UUID generation"

AI: "Instalando uuid (5KB)..."
[just adds it, no alternatives needed]
```

### Example 3: Native Alternative Exists âœ…

```
User: "Format dates as 'DD/MM/YYYY'"

AI: "Para formataÃ§Ã£o de datas:

ğŸ“¦ OpÃ§Ã£o A: Nativa (Intl.DateTimeFormat)
Tamanho: 0 KB (built-in)
âœ… PrÃ³s: Zero dependencies, i18n suporte
âš ï¸ Contras: API mais verbosa

ğŸ“¦ OpÃ§Ã£o B: date-fns
Tamanho: 5 KB (apenas funÃ§Ã£o format)
âœ… PrÃ³s: API simples e clara
âš ï¸ Contras: +5KB no bundle

Para caso simples como este, recomendo OpÃ§Ã£o A (nativa).
Concorda ou prefere date-fns?"
```

## Remember

**>500kb = present alternatives with sizes and trade-offs.**

Let user decide based on:
- Bundle size impact
- Features needed
- Maintenance status
- Team familiarity

Don't hide the cost of dependencies.
